import pygame,anim,random


# DEFAULT CHARACTER
class CharTemplate(pygame.sprite.Sprite):
    #default image if unchanged
    image = pygame.Surface((30, 30), pygame.SRCALPHA)
    pygame.draw.circle(image, "red", (15, 15), 15)
    
    def __init__(self,sprites:dict,level:int,formation_position:tuple,offset:tuple,data:dict,default_image = True,**kwargs):
        #initializes sprite code
        pygame.sprite.Sprite.__init__(self)
        
        #TAKING ARGUMENTS
        self.sprites = sprites
        self.level = level
        self.offset = offset
        self.data = data

        #default character code
        self.state = "enter" #current behavior patterns
        self.health=1 #Health for characters
        self.scorevalue=100 #Score given to player
        self.idlePos = [(formation_position[0]+self.offset[0]),(formation_position[1]+self.offset[1])] # current position in idle
        self.dead = (self.health <= 0)

        #IMAGE CODE
        self.animation_frame=0
        self.animation_frame_counter=0
        if default_image:
            self.image = CharTemplate.image
            self.rect = self.image.get_rect()
    
        #SHOOT CODE    
        self.shoot_times = [] #the maximum amount will be like 10, which would only be achieved after level 100 or so
        #shoot times are not generated by default

        #STATE CODE
        self.frames_in_state = 0 #counter for states. reset at the end of every state, but risen every frame, whether used or not.

        #CONTAINER CODE -- ITEM DROPPER
        self.container:tuple = None #a tuple, containing the type of item and the name of the item. the second index is usually unused if the item is not a bullet.


    def update(self):
        self.state_update()
        self.collision_update()
        self.animation_update()

    def animation_update(self):
        pass

    def state_update(self):
        self.frames_in_state += 1
        if self.state=="enter": self.state_enter()
        if self.state=="idle_search": self.state_idle_search()
        if self.state=="idle": self.state_idle()
        if self.state=="attack": self.state_attack()
        if self.state=="return": self.state_return()

    def state_enter(self):
        self.stchg('idle_search')

    def state_idle_search(self):
        #Slowly dragging the character to the title screen
        horizontal_condition_met = abs(self.idlePos[0] - self.rect.center[0]) <= 5
        vertical_condition_met = abs(self.idlePos[1] - self.rect.center[1]) <= 5
        if not horizontal_condition_met or not vertical_condition_met:
            if not horizontal_condition_met:
                if self.idlePos[0] < self.rect.center[0]:
                    self.rect.x -= 5
                elif self.idlePos[0] > self.rect.center[0]:
                    self.rect.x += 5
            if not vertical_condition_met:
                if self.idlePos[1] < self.rect.center[1]:
                    self.rect.y -= 3
                elif self.idlePos[1] > self.rect.center[1]:
                    self.rect.y += 3
        else: 
            self.stchg('idle')

    def state_idle(self):
        #this is the only state that does not have a frame counter
        #this is because it does not automatically exit
        self.rect.center=self.idlePos

    def state_attack(self):
        #same default as state_enter
        if True: 
            self.stchg("return") 

    def state_return(self):
        if True:
            self.stchg("idle_search") #or 'idle'  

    def collision_update(self):
        #most of what this does is check for health
        #collision is a universal term for health, positioning, etc.
        #DO NOT CHANGE THIS. THIS WILL MESS UP THE FORMATION
        self.dead = (self.health <= 0)
        if self.dead:
            self.kill(reason="health")
        
        

    def on_collide(self,
                   collide_type:int #the collide_type refers to the sprite group numbers. 0 for universal (not used), 1 for other player elements, 2 for enemies
                   ):
        #5/26/23 - Updating health shizznit if interaction with "player type" class
        if collide_type == 1:
            self.health -= 1

    def formationUpdate(self,new_pos:tuple):
        #following formation
        self.idlePos = [
            (new_pos[0] + self.offset[0]),
            (new_pos[1] + self.offset[1])]
    
    def stchg(self,state:str): #changing the state 
        self.frames_in_state = 0 
        self.state = state
    
    def kill(self,reason=None):
        if reason == "health":
            self.data["score"] += self.scorevalue
        pygame.sprite.Sprite.kill(self)
        self.data["score"]
       



class Nope(CharTemplate):
    def __init__(self,sprites:dict,level:int,formation_position:tuple,offset:tuple,data:dict,**kwargs):
        CharTemplate.__init__(self,sprites=sprites,level=level,formation_position=formation_position,offset=offset,data=data,default_image=False,**kwargs)
        #img code
        self.sh = anim.Spritesheet("NOPE","idle")
        self.image = anim.all_loaded_spritesheets[self.sh.name][1][self.sh.image_displayed]
        self.rect = self.image.get_rect()

        #06/06/23 - enter state - copied from revC
        self.enter_dir = random.choice(('l','r')) #where the character is entering FROM
        self.rect.center = (450,300) if self.enter_dir == 'r' else (0,300)
        self.parabola = (450,400) if self.enter_dir == 'r' else (25,400)

    def update(self):
        CharTemplate.update(self)
        self.image = self.sh.update()

    def state_enter(self):
        self.rect.x = self.rect.x-2 if self.enter_dir == 'r' else self.rect.x+2

        self.rect.y = (-(1 / 50) * ((self.rect.x + (
            self.parabola[0] if self.enter_dir == 'l' else (self.parabola[0]*-1) )
            ) ** 2) + self.parabola[1])

        if abs(225-self.rect.x) <= 100 or abs(100 - self.rect.y) <= 50:
            self.stchg("idle_search")
    
    def state_attack(self):
        self.rect.y+=5
        if self.rect.top>=600:
            self.rect.bottom=0
            self.frames_in_state = 0
            self.stchg('return') 
    
    

loaded = {
    "nope":Nope
    }
